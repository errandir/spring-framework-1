include::page$attributes.adoc[]
[[aop-ataspectj]]
== @AspectJ support

@AspectJ refers to a style of declaring aspects as regular Java classes annotated with
annotations. The @AspectJ style was introduced by the
https://www.eclipse.org/aspectj[AspectJ project] as part of the AspectJ 5 release. Spring
interprets the same annotations as AspectJ 5, using a library supplied by AspectJ
for pointcut parsing and matching. The AOP runtime is still pure Spring AOP, though, and
there is no dependency on the AspectJ compiler or weaver.

NOTE: Using the AspectJ compiler and weaver enables use of the full AspectJ language and
is discussed in xref:aop:aop-using-aspectj.adoc#aop-using-aspectj[aop-using-aspectj].



[[aop-aspectj-support]]
=== Enabling @AspectJ Support

To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for
configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on
whether or not they are advised by those aspects. By auto-proxying, we mean that, if Spring
determines that a bean is advised by one or more aspects, it automatically generates
a proxy for that bean to intercept method invocations and ensures that advice is executed
as needed.

The @AspectJ support can be enabled with XML- or Java-style configuration. In either
case, you also need to ensure that AspectJ's `aspectjweaver.jar` library is on the
classpath of your application (version 1.8 or later). This library is available in the
`lib` directory of an AspectJ distribution or from the Maven Central repository.


[[aop-enable-aspectj-java]]
==== Enabling @AspectJ Support with Java Configuration

To enable @AspectJ support with Java `@Configuration`, add the `@EnableAspectJAutoProxy`
annotation, as the following example shows:
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableAspectJAutoProxy
	class AppConfig
----

[[aop-enable-aspectj-xml]]
==== Enabling @AspectJ Support with XML Configuration

To enable @AspectJ support with XML-based configuration, use the `aop:aspectj-autoproxy`
element, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>
----

This assumes that you use schema support as described in
xref:appendix:xsd-schemas.adoc#xsd-schemas[XML Schema-based configuration].
See xref:appendix:xsd-schemas:xsd-schemas-aop.adoc#xsd-schemas-aop[the AOP schema] for how to
import the tags in the `aop` namespace.



[[aop-at-aspectj]]
=== Declaring an Aspect

With @AspectJ support enabled, any bean defined in your application context with a
class that is an @AspectJ aspect (has the `@Aspect` annotation) is automatically
detected by Spring and used to configure Spring AOP. The next two examples show the
minimal definition required for a not-very-useful aspect.

The first of the two example shows a regular bean definition in the application
context that points to a bean class that has the `@Aspect` annotation:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myAspect" class="org.xyz.NotVeryUsefulAspect">
		<!-- configure properties of the aspect here -->
	</bean>
----

The second of the two examples shows the `NotVeryUsefulAspect` class definition,
which is annotated with the `org.aspectj.lang.annotation.Aspect` annotation;

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package org.xyz;
	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	public class NotVeryUsefulAspect {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package org.xyz

	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	class NotVeryUsefulAspect
----

Aspects (classes annotated with `@Aspect`) can have methods and fields, the same as any
other class. They can also contain pointcut, advice, and introduction (inter-type)
declarations.

.Autodetecting aspects through component scanning
NOTE: You can register aspect classes as regular beans in your Spring XML configuration or
autodetect them through classpath scanning -- the same as any other Spring-managed bean.
However, note that the `@Aspect` annotation is not sufficient for autodetection in
the classpath. For that purpose, you need to add a separate `@Component` annotation
(or, alternatively, a custom stereotype annotation that qualifies, as per the rules of
Spring's component scanner).

.Advising aspects with other aspects?
NOTE: In Spring AOP, aspects themselves cannot be the targets of advice
from other aspects. The `@Aspect` annotation on a class marks it as an aspect and,
hence, excludes it from auto-proxying.



[[aop-pointcuts]]
=== Declaring a Pointcut

Pointcuts determine join points of interest and thus enable us to control
when advice executes. Spring AOP only supports method execution join points for Spring
beans, so you can think of a pointcut as matching the execution of methods on Spring
beans. A pointcut declaration has two parts: a signature comprising a name and any
parameters and a pointcut expression that determines exactly which method
executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut
signature is provided by a regular method definition, and the pointcut expression is
indicated by using the `@Pointcut` annotation (the method serving as the pointcut signature
must have a `void` return type).

An example may help make this distinction between a pointcut signature and a pointcut
expression clear. The following example defines a pointcut named `anyOldTransfer` that
matches the execution of any method named `transfer`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private void anyOldTransfer() {} // the pointcut signature
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private fun anyOldTransfer() {} // the pointcut signature
----

The pointcut expression that forms the value of the `@Pointcut` annotation is a regular
AspectJ 5 pointcut expression. For a full discussion of AspectJ's pointcut language, see
the https://www.eclipse.org/aspectj/doc/released/progguide/index.html[AspectJ
Programming Guide] (and, for extensions, the
https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html[AspectJ 5
Developer's Notebook]) or one of the books on AspectJ (such as _Eclipse AspectJ_, by Colyer
et. al., or _AspectJ in Action_, by Ramnivas Laddad).


[[aop-pointcuts-designators]]
==== Supported Pointcut Designators

Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
expressions:

* `execution`: For matching method execution join points. This is the primary
  pointcut designator to use when working with Spring AOP.
* `within`: Limits matching to join points within certain types (the execution
  of a method declared within a matching type when using Spring AOP).
* `this`: Limits matching to join points (the execution of methods when using Spring
  AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.
* `target`: Limits matching to join points (the execution of methods when using
  Spring AOP) where the target object (application object being proxied) is an instance
  of the given type.
* `args`: Limits matching to join points (the execution of methods when using Spring
  AOP) where the arguments are instances of the given types.
* `@target`: Limits matching to join points (the execution of methods when using
  Spring AOP) where the class of the executing object has an annotation of the given type.
* `@args`: Limits matching to join points (the execution of methods when using Spring
  AOP) where the runtime type of the actual arguments passed have annotations of the
  given types.
* `@within`: Limits matching to join points within types that have the given
  annotation (the execution of methods declared in types with the given annotation when
  using Spring AOP).
* `@annotation`: Limits matching to join points where the subject of the join point
  (the method being executed in Spring AOP) has the given annotation.

.Other pointcut types
****
The full AspectJ pointcut language supports additional pointcut designators that are not
supported in Spring: `call`, `get`, `set`, `preinitialization`,
`staticinitialization`, `initialization`, `handler`, `adviceexecution`, `withincode`, `cflow`,
`cflowbelow`, `if`, `@this`, and `@withincode`. Use of these pointcut designators in pointcut
expressions interpreted by Spring AOP results in an `IllegalArgumentException` being
thrown.

The set of pointcut designators supported by Spring AOP may be extended in future
releases to support more of the AspectJ pointcut designators.
****

Because Spring AOP limits matching to only method execution join points, the preceding discussion
of the pointcut designators gives a narrower definition than you can find in the
AspectJ programming guide. In addition, AspectJ itself has type-based semantics and, at
an execution join point, both `this` and `target` refer to the same object: the
object executing the method. Spring AOP is a proxy-based system and differentiates
between the proxy object itself (which is bound to `this`) and the target object behind the
proxy (which is bound to `target`).

[NOTE]
====
Due to the proxy-based nature of Spring's AOP framework, calls within the target object
are, by definition, not intercepted. For JDK proxies, only public interface method
calls on the proxy can be intercepted. With CGLIB, public and protected method calls on
the proxy are intercepted (and even package-visible methods, if necessary). However,
common interactions through proxies should always be designed through public signatures.

Note that pointcut definitions are generally matched against any intercepted method.
If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with
potential non-public interactions through proxies, it needs to be defined accordingly.

If your interception needs include method calls or even constructors within the target
class, consider the use of Spring-driven xref:aop:aop-using-aspectj:aop-aj-ltw.adoc#aop-aj-ltw[native AspectJ weaving] instead
of Spring's proxy-based AOP framework. This constitutes a different mode of AOP usage
with different characteristics, so be sure to make yourself familiar with weaving
before making a decision.
====

Spring AOP also supports an additional PCD named `bean`. This PCD lets you limit
the matching of join points to a particular named Spring bean or to a set of named
Spring beans (when using wildcards). The `bean` PCD has the following form:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	bean(idOrNameOfBean)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	bean(idOrNameOfBean)
----

The `idOrNameOfBean` token can be the name of any Spring bean. Limited wildcard
support that uses the `*` character is provided, so, if you establish some naming
conventions for your Spring beans, you can write a `bean` PCD expression
to select them. As is the case with other pointcut designators, the `bean` PCD can
be used with the `&&` (and), `||` (or), and `!` (negation) operators, too.

[NOTE]
====
The `bean` PCD is supported only in Spring AOP and not in
native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that
AspectJ defines and is, therefore, not available for aspects declared in the `@Aspect` model.

The `bean` PCD operates at the instance level (building on the Spring bean name
concept) rather than at the type level only (to which weaving-based AOP is limited).
Instance-based pointcut designators are a special capability of Spring's
proxy-based AOP framework and its close integration with the Spring bean factory, where
it is natural and straightforward to identify specific beans by name.
====


[[aop-pointcuts-combining]]
==== Combining Pointcut Expressions

You can combine pointcut expressions by using `&&,` `||` and `!`. You can also refer to
pointcut expressions by name. The following example shows three pointcut expressions:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(public * *(..))")
	private void anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.someapp.trading..*)")
	private void inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private void tradingOperation() {} // <3>
----
<1> `anyPublicOperation` matches if a method execution join point represents the execution
of any public method.
<2> `inTrading` matches if a method execution is in the trading module.
<3> `tradingOperation` matches if a method execution represents any public method in the
trading module.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(public * *(..))")
	private fun anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.someapp.trading..*)")
	private fun inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private fun tradingOperation() {} // <3>
----
<1> `anyPublicOperation` matches if a method execution join point represents the execution
of any public method.
<2> `inTrading` matches if a method execution is in the trading module.
<3> `tradingOperation` matches if a method execution represents any public method in the
trading module.

It is a best practice to build more complex pointcut expressions out of smaller named
components, as shown earlier. When referring to pointcuts by name, normal Java visibility
rules apply (you can see private pointcuts in the same type, protected pointcuts in the
hierarchy, public pointcuts anywhere, and so on). Visibility does not affect pointcut
matching.


[[aop-common-pointcuts]]
==== Sharing Common Pointcut Definitions

When working with enterprise applications, developers often want to refer to modules of the
application and particular sets of operations from within several aspects. We recommend
defining a "`SystemArchitecture`" aspect that captures common pointcut expressions for
this purpose. Such an aspect typically resembles the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.someapp;

	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Pointcut;

	@Aspect
	public class SystemArchitecture {

		/**
		 * A join point is in the web layer if the method is defined
		 * in a type in the com.xyz.someapp.web package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.web..*)")
		public void inWebLayer() {}

		/**
		 * A join point is in the service layer if the method is defined
		 * in a type in the com.xyz.someapp.service package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.service..*)")
		public void inServiceLayer() {}

		/**
		 * A join point is in the data access layer if the method is defined
		 * in a type in the com.xyz.someapp.dao package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.someapp.dao..*)")
		public void inDataAccessLayer() {}

		/**
		 * A business service is the execution of any method defined on a service
		 * interface. This definition assumes that interfaces are placed in the
		 * "service" package, and that implementation types are in sub-packages.
		 *
		 * If you group service interfaces by functional area (for example,
		 * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
		 * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
		 * could be used instead.
		 *
		 * Alternatively, you can write the expression using the 'bean'
		 * PCD, like so "bean(*Service)". (This assumes that you have
		 * named your Spring service beans in a consistent fashion.)
		 */
		@Pointcut("execution(* com.xyz.someapp..service.*.*(..))")
		public void businessService() {}

		/**
		 * A data access operation is the execution of any method defined on a
		 * dao interface. This definition assumes that interfaces are placed in the
		 * "dao" package, and that implementation types are in sub-packages.
		 */
		@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
		public void dataAccessOperation() {}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.someapp

	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Pointcut

	import org.springframework.aop.Pointcut

	@Aspect
	class SystemArchitecture {

		/**
		* A join point is in the web layer if the method is defined
		* in a type in the com.xyz.someapp.web package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.web..*)")
		fun inWebLayer() {
		}

		/**
		* A join point is in the service layer if the method is defined
		* in a type in the com.xyz.someapp.service package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.service..*)")
		fun inServiceLayer() {
		}

		/**
		* A join point is in the data access layer if the method is defined
		* in a type in the com.xyz.someapp.dao package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.someapp.dao..*)")
		fun inDataAccessLayer() {
		}

		/**
		* A business service is the execution of any method defined on a service
		* interface. This definition assumes that interfaces are placed in the
		* "service" package, and that implementation types are in sub-packages.
		*
		* If you group service interfaces by functional area (for example,
		* in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then
		* the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"
		* could be used instead.
		*
		* Alternatively, you can write the expression using the 'bean'
		* PCD, like so "bean(*Service)". (This assumes that you have
		* named your Spring service beans in a consistent fashion.)
		*/
		@Pointcut("execution(* com.xyz.someapp..service.*.*(..))")
		fun businessService() {
		}

		/**
		* A data access operation is the execution of any method defined on a
		* dao interface. This definition assumes that interfaces are placed in the
		* "dao" package, and that implementation types are in sub-packages.
		*/
		@Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
		fun dataAccessOperation() {
		}

	}
----

You can refer to the pointcuts defined in such an aspect anywhere you need a
pointcut expression. For example, to make the service layer transactional, you could
write the following:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>
		<aop:advisor
			pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
			advice-ref="tx-advice"/>
	</aop:config>

	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
----

The `<aop:config>` and `<aop:advisor>` elements are discussed in xref:aop:aop-schema.adoc#aop-schema[aop-schema]. The
transaction elements are discussed in xref:transaction:transaction.adoc#transaction[Transaction Management].


[[aop-pointcuts-examples]]
==== Examples

Spring AOP users are likely to use the `execution` pointcut designator the most often.
The format of an execution expression follows:

[literal,subs="verbatim,quotes"]
----
	execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
				throws-pattern?)
----

All parts except the returning type pattern (`ret-type-pattern` in the preceding snippet),
the name pattern, and the parameters pattern are optional. The returning type pattern determines
what the return type of the method must be in order for a join point to be matched.
`{asterisk}` is most frequently used as the returning type pattern. It matches any return
type. A fully-qualified type name matches only when the method returns the given
type. The name pattern matches the method name. You can use the `{asterisk}` wildcard as all or
part of a name pattern. If you specify a declaring type pattern,
include a trailing `.` to join it to the name pattern component.
The parameters pattern is slightly more complex: `()` matches a
method that takes no parameters, whereas `(..)` matches any number (zero or more) of parameters.
The `({asterisk})` pattern matches a method that takes one parameter of any type.
`(*,String)` matches a method that takes two parameters. The first can be of any type, while the
second must be a `String`. Consult the
https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html[Language
Semantics] section of the AspectJ Programming Guide for more information.

The following examples show some common pointcut expressions:

* The execution of any public method:
+
[literal,subs="verbatim,quotes"]
----
	execution(public * *(..))
----

* The execution of any method with a name that begins with `set`:
+
[literal,subs="verbatim,quotes"]
----
	execution(* set*(..))
----

* The execution of any method defined by the `AccountService` interface:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.AccountService.*(..))
----

* The execution of any method defined in the `service` package:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.\*.*(..))
----

* The execution of any method defined in the service package or one of its sub-packages:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service..\*.*(..))
----

* Any join point (method execution only in Spring AOP) within the service package:
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service.*)
----

* Any join point (method execution only in Spring AOP) within the service package or one of its
sub-packages:
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service..*)
----

* Any join point (method execution only in Spring AOP) where the proxy implements the
`AccountService` interface:
+
[literal,subs="verbatim,quotes"]
----
	this(com.xyz.service.AccountService)
----
+
NOTE: 'this' is more commonly used in a binding form. See the section on xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice]
for how to make the proxy object available in the advice body.

* Any join point (method execution only in Spring AOP) where the target object
implements the `AccountService` interface:
+
[literal,subs="verbatim,quotes"]
----
	target(com.xyz.service.AccountService)
----
+
NOTE: 'target' is more commonly used in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section
for how to make the target object available in the advice body.

* Any join point (method execution only in Spring AOP) that takes a single parameter
and where the argument passed at runtime is `Serializable`:
+
[literal,subs="verbatim,quotes"]
----
	args(java.io.Serializable)
----
+
NOTE: 'args' is more commonly used in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section
for how to make the method arguments available in the advice body.
+
Note that the pointcut given in this example is different from `execution(*
*(java.io.Serializable))`. The args version matches if the argument passed at runtime is
`Serializable`, and the execution version matches if the method signature declares a single
parameter of type `Serializable`.

* Any join point (method execution only in Spring AOP) where the target object has a
`@Transactional` annotation:
+
[literal,subs="verbatim,quotes"]
----
	@target(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: You can also use '@target' in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section for
how to make the annotation object available in the advice body.

* Any join point (method execution only in Spring AOP) where the declared type of the
target object has an `@Transactional` annotation:
+
[literal,subs="verbatim,quotes"]
----
	@within(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: You can also use '@within' in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section for
how to make the annotation object available in the advice body.

* Any join point (method execution only in Spring AOP) where the executing method has an
`@Transactional` annotation:
+
[literal,subs="verbatim,quotes"]
----
	@annotation(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: You can also use '@annotation' in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section
for how to make the annotation object available in the advice body.

* Any join point (method execution only in Spring AOP) which takes a single parameter,
and where the runtime type of the argument passed has the `@Classified` annotation:
+
[literal,subs="verbatim,quotes"]
----
	@args(com.xyz.security.Classified)
----
+
NOTE: You can also use '@args' in a binding form. See the xref:aop:aop-ataspectj:aop-advice.adoc#aop-advice[aop-advice] section
how to make the annotation object(s) available in the advice body.

* Any join point (method execution only in Spring AOP) on a Spring bean named
`tradeService`:
+
[literal,subs="verbatim,quotes"]
----
	bean(tradeService)
----

* Any join point (method execution only in Spring AOP) on Spring beans having names that
match the wildcard expression `*Service`:
+
[literal,subs="verbatim,quotes"]
----
	bean(*Service)
----


[[writing-good-pointcuts]]
==== Writing Good Pointcuts

During compilation, AspectJ processes pointcuts in order to optimize matching
performance. Examining code and determining if each join point matches (statically or
dynamically) a given pointcut is a costly process. (A dynamic match means the match
cannot be fully determined from static analysis and that a test is placed in the code to
determine if there is an actual match when the code is running). On first encountering a
pointcut declaration, AspectJ rewrites it into an optimal form for the matching
process. What does this mean? Basically, pointcuts are rewritten in DNF (Disjunctive
Normal Form) and the components of the pointcut are sorted such that those components
that are cheaper to evaluate are checked first. This means you do not have to worry
about understanding the performance of various pointcut designators and may supply them
in any order in a pointcut declaration.

However, AspectJ can work only with what it is told. For optimal performance of
matching, you should think about what they are trying to achieve and narrow the search
space for matches as much as possible in the definition. The existing designators
naturally fall into one of three groups: kinded, scoping, and contextual:

* Kinded designators select a particular kind of join point:
`execution`, `get`, `set`, `call`, and `handler`.
* Scoping designators select a group of join points of interest
(probably of many kinds): `within` and `withincode`
* Contextual designators match (and optionally bind) based on context:
`this`, `target`, and `@annotation`

A well written pointcut should include at least the first two types (kinded and
scoping). You can include the contextual designators to match based on
join point context or bind that context for use in the advice. Supplying only a
kinded designator or only a contextual designator works but could affect weaving
performance (time and memory used), due to extra processing and analysis. Scoping
designators are very fast to match, and using them usage means AspectJ can very quickly
dismiss groups of join points that should not be further processed. A good
pointcut should always include one if possible.



[[aop-advice]]
=== Declaring Advice

Advice is associated with a pointcut expression and runs before, after, or around
method executions matched by the pointcut. The pointcut expression may be either a
simple reference to a named pointcut or a pointcut expression declared in place.


[[aop-advice-before]]
==== Before Advice

You can declare before advice in an aspect by using the `@Before` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}

	}
----

If we use an in-place pointcut expression, we could rewrite the preceding example as the
following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		fun doAccessCheck() {
			// ...
		}

	}
----


[[aop-advice-after-returning]]
==== After Returning Advice

After returning advice runs when a matched method execution returns normally. You can
declare it by using the `@AfterReturning` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}

----

NOTE: You can have multiple advice declarations (and other members
as well), all inside the same aspect. We show only a single advice declaration in
these examples to focus the effect of each one.

Sometimes, you need access in the advice body to the actual value that was returned. You
can use the form of `@AfterReturning` that binds the return value to get that access, as
the following example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning(
			pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
			returning="retVal")
		public void doAccessCheck(Object retVal) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning = "retVal")
		fun doAccessCheck(retVal: Any) {
			// ...
		}

	}
----

The name used in the `returning` attribute must correspond to the name of a parameter in
the advice method. When a method execution returns, the return value is passed to
the advice method as the corresponding argument value. A `returning` clause also
restricts matching to only those method executions that return a value of the specified
type (in this case, `Object`, which matches any return value).

Please note that it is not possible to return a totally different reference when
using after returning advice.


[[aop-advice-after-throwing]]
==== After Throwing Advice

After throwing advice runs when a matched method execution exits by throwing an
exception. You can declare it by using the `@AfterThrowing` annotation, as the following
example shows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doRecoveryActions() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doRecoveryActions() {
			// ...
		}

	}
----

Often, you want the advice to run only when exceptions of a given type are thrown, and
you also often need access to the thrown exception in the advice body. You can use the
`throwing` attribute to both restrict matching (if desired -- use `Throwable` as the
exception type otherwise) and bind the thrown exception to an advice parameter. The
following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing(
			pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
			throwing="ex")
		public void doRecoveryActions(DataAccessException ex) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing(pointcut = "com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing = "ex")
		fun doRecoveryActions(ex: DataAccessException) {
			// ...
		}

	}
----

The name used in the `throwing` attribute must correspond to the name of a parameter in
the advice method. When a method execution exits by throwing an exception, the exception
is passed to the advice method as the corresponding argument value. A `throwing`
clause also restricts matching to only those method executions that throw an exception
of the specified type ( `DataAccessException`, in this case).


[[aop-advice-after-finally]]
==== After (Finally) Advice

After (finally) advice runs when a matched method execution exits. It is declared by
using the `@After` annotation. After advice must be prepared to handle both normal and
exception return conditions. It is typically used for releasing resources and similar purposes.
The following example shows how to use after finally advice:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.After;

	@Aspect
	public class AfterFinallyExample {

		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		public void doReleaseLock() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.After

	@Aspect
	class AfterFinallyExample {

		@After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
		fun doReleaseLock() {
			// ...
		}

	}
----


[[aop-ataspectj-around-advice]]
==== Around Advice

The last kind of advice is around advice. Around advice runs "`around`" a matched method's
execution. It has the opportunity to do work both before and after the method executes
and to determine when, how, and even if the method actually gets to execute at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer, for example). Always
use the least powerful form of advice that meets your requirements (that is, do not use
around advice if before advice would do).

Around advice is declared by using the `@Around` annotation. The first parameter of the
advice method must be of type `ProceedingJoinPoint`. Within the body of the advice,
calling `proceed()` on the `ProceedingJoinPoint` causes the underlying method to
execute. The `proceed` method can also pass in an `Object[]`. The values
in the array are used as the arguments to the method execution when it proceeds.

NOTE: The behavior of `proceed` when called with an `Object[]` is a little different than the
behavior of `proceed` for around advice compiled by the AspectJ compiler. For around
advice written using the traditional AspectJ language, the number of arguments passed to
`proceed` must match the number of arguments passed to the around advice (not the number
of arguments taken by the underlying join point), and the value passed to proceed in a
given argument position supplants the original value at the join point for the entity
the value was bound to (do not worry if this does not make sense right now). The approach
taken by Spring is simpler and a better match to its proxy-based, execution-only
semantics. You only need to be aware of this difference if you compile @AspectJ
aspects written for Spring and use `proceed` with arguments with the AspectJ compiler
and weaver. There is a way to write such aspects that is 100% compatible across both
Spring AOP and AspectJ, and this is discussed in the
xref:aop:aop-ataspectj:aop-advice.adoc#aop-ataspectj-advice-params[following section on advice parameters].

The following example shows how to use around advice:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.ProceedingJoinPoint;

	@Aspect
	public class AroundExample {

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
			// start stopwatch
			Object retVal = pjp.proceed();
			// stop stopwatch
			return retVal;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Around
	import org.aspectj.lang.ProceedingJoinPoint

	@Aspect
	class AroundExample {

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
			// start stopwatch
			val retVal = pjp.proceed()
			// stop stopwatch
			return pjp.proceed()
		}

	}
----

The value returned by the around advice is the return value seen by the caller of
the method. For example, a simple caching aspect could return a value from a cache if it
has one and invoke `proceed()` if it does not. Note that `proceed` may be invoked once,
many times, or not at all within the body of the around advice. All of these are
legal.


[[aop-ataspectj-advice-params]]
==== Advice Parameters

Spring offers fully typed advice, meaning that you declare the parameters you need
in the advice signature (as we saw earlier for the returning and throwing examples) rather
than work with `Object[]` arrays all the time. We see how to make argument and other
contextual values available to the advice body later in this section. First, we take a look at
how to write generic advice that can find out about the method the advice is currently
advising.

[[aop-ataspectj-advice-params-the-joinpoint]]
===== Access to the Current `JoinPoint`

Any advice method may declare, as its first parameter, a parameter of type
`org.aspectj.lang.JoinPoint` (note that around advice is required to declare
a first parameter of type `ProceedingJoinPoint`, which is a subclass of `JoinPoint`. The
`JoinPoint` interface provides a number of useful methods:

* `getArgs()`: Returns the method arguments.
* `getThis()`: Returns the proxy object.
* `getTarget()`: Returns the target object.
* `getSignature()`: Returns a description of the method that is being advised.
* `toString()`: Prints a useful description of the method being advised.

See the https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html[javadoc] for more detail.

[[aop-ataspectj-advice-params-passing]]
===== Passing Parameters to Advice

We have already seen how to bind the returned value or exception value (using after
returning and after throwing advice). To make argument values available to the advice
body, you can use the binding form of `args`. If you use a parameter name in place of a
type name in an args expression, the value of the corresponding argument is
passed as the parameter value when the advice is invoked. An example should make this
clearer. Suppose you want to advise the execution of DAO operations that take an `Account`
object as the first parameter, and you need access to the account in the advice body.
You could write the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	fun validateAccount(account: Account) {
		// ...
	}
----

The `args(account,..)` part of the pointcut expression serves two purposes. First, it
restricts matching to only those method executions where the method takes at least one
parameter, and the argument passed to that parameter is an instance of `Account`.
Second, it makes the actual `Account` object available to the advice through the `account`
parameter.

Another way of writing this is to declare a pointcut that "`provides`" the `Account`
object value when it matches a join point, and then refer to the named pointcut
from the advice. This would look as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	private void accountDataAccessOperation(Account account) {}

	@Before("accountDataAccessOperation(account)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() && args(account,..)")
	private fun accountDataAccessOperation(account: Account) {
	}

	@Before("accountDataAccessOperation(account)")
	fun validateAccount(account: Account) {
		// ...
	}
----

See the AspectJ programming guide for more
details.

The proxy object ( `this`), target object ( `target`), and annotations ( `@within`,
`@target`, `@annotation`, and `@args`) can all be bound in a similar fashion. The next two
examples show how to match the execution of methods annotated with an
`@Auditable` annotation and extract the audit code:

The first of the two examples shows the definition of the `@Auditable` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.METHOD)
	public @interface Auditable {
		AuditCode value();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	@Target(AnnotationTarget.FUNCTION)
	annotation class Auditable(val value: AuditCode)
----

The second of the two examples shows the advice that matches the execution of `@Auditable` methods:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	public void audit(Auditable auditable) {
		AuditCode code = auditable.value();
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	fun audit(auditable: Auditable) {
		val code = auditable.value()
		// ...
	}
----

[[aop-ataspectj-advice-params-generics]]
===== Advice Parameters and Generics

Spring AOP can handle generics used in class declarations and method parameters. Suppose
you have a generic type like the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Sample<T> {
		void sampleGenericMethod(T param);
		void sampleGenericCollectionMethod(Collection<T> param);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Sample<T> {
		fun sampleGenericMethod(param: T)
		fun sampleGenericCollectionMethod(param: Collection<T>)
	}
----

You can restrict interception of method types to certain parameter types by
typing the advice parameter to the parameter type for which you want to intercept the method:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	public void beforeSampleMethod(MyType param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	fun beforeSampleMethod(param: MyType) {
		// Advice implementation
	}
----

This approach does not work for generic collections. So you cannot define a
pointcut as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	public void beforeSampleMethod(Collection<MyType> param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	fun beforeSampleMethod(param: Collection<MyType>) {
		// Advice implementation
	}
----

To make this work, we would have to inspect every element of the collection, which is not
reasonable, as we also cannot decide how to treat `null` values in general. To achieve
something similar to this, you have to type the parameter to `Collection<?>` and manually
check the type of the elements.

[[aop-ataspectj-advice-params-names]]
===== Determining Argument Names

The parameter binding in advice invocations relies on matching names used in pointcut
expressions to declared parameter names in advice and pointcut method signatures.
Parameter names are not available through Java reflection, so Spring AOP uses the
following strategy to determine parameter names:

* If the parameter names have been explicitly specified by the user, the specified
  parameter names are used. Both the advice and the pointcut annotations have
  an optional `argNames` attribute that you can use to specify the argument names of
  the annotated method. These argument names are available at runtime. The following example
  shows how to use the `argNames` attribute:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code and bean
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code and bean
	}
----


If the first parameter is of the `JoinPoint`, `ProceedingJoinPoint`, or
`JoinPoint.StaticPart` type, you can leave out the name of the parameter from the value
of the `argNames` attribute. For example, if you modify the preceding advice to receive
the join point object, the `argNames` attribute need not include it:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(JoinPoint jp, Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code, bean, and jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code, bean, and jp
	}
----

The special treatment given to the first parameter of the `JoinPoint`,
`ProceedingJoinPoint`, and `JoinPoint.StaticPart` types is particularly convenient for
advice instances that do not collect any other join point context. In such situations, you may
omit the `argNames` attribute. For example, the following advice need not declare
the `argNames` attribute:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	public void audit(JoinPoint jp) {
		// ... use jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	fun audit(jp: JoinPoint) {
		// ... use jp
	}
----

* Using the `'argNames'` attribute is a little clumsy, so if the `'argNames'` attribute
  has not been specified,  Spring AOP looks at the debug information for the
  class and tries to determine the parameter names from the local variable table. This
  information is present as long as the classes have been compiled with debug
  information ( `'-g:vars'` at a minimum). The consequences of compiling with this flag
  on are: (1) your code is slightly easier to understand (reverse engineer), (2)
  the class file sizes are very slightly bigger (typically inconsequential), (3) the
  optimization to remove unused local variables is not  applied by your compiler. In
  other words, you should encounter no difficulties by building with this flag on.
+
NOTE: If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the
debug information, you need not add the `argNames` attribute, as the compiler
retain the needed information.

* If the code has been compiled without the necessary debug information, Spring AOP
  tries to deduce the pairing of binding variables to parameters (for example, if
  only one variable is bound in the pointcut expression, and the advice method
  takes only one parameter, the pairing is obvious). If the binding of variables is
  ambiguous given the available information, an `AmbiguousBindingException` is
  thrown.
* If all of the above strategies fail, an `IllegalArgumentException` is thrown.

[[aop-ataspectj-advice-proceeding-with-the-call]]
===== Proceeding with Arguments

We remarked earlier that we would describe how to write a `proceed` call with
arguments that works consistently across Spring AOP and AspectJ. The solution is
to ensure that the advice signature binds each of the method parameters in order.
The following example shows how to do so:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
			String accountHolderNamePattern) throws Throwable {
		String newPattern = preProcess(accountHolderNamePattern);
		return pjp.proceed(new Object[] {newPattern});
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.SystemArchitecture.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
							accountHolderNamePattern: String): Any {
		val newPattern = preProcess(accountHolderNamePattern)
		return pjp.proceed(arrayOf<Any>(newPattern))
	}
----

In many cases, you do this binding anyway (as in the preceding example).


[[aop-ataspectj-advice-ordering]]
==== Advice Ordering

What happens when multiple pieces of advice all want to run at the same join point?
Spring AOP follows the same precedence rules as AspectJ to determine the order of advice
execution. The highest precedence advice runs first "`on the way in`" (so, given two pieces
of before advice, the one with highest precedence runs first). "`On the way out`" from a
join point, the highest precedence advice runs last (so, given two pieces of after
advice, the one with the highest precedence will run second).

When two pieces of advice defined in different aspects both need to run at the same
join point, unless you specify otherwise, the order of execution is undefined. You can
control the order of execution by specifying precedence. This is done in the normal
Spring way by either implementing the `org.springframework.core.Ordered` interface in
the aspect class or annotating it with the `Order` annotation. Given two aspects, the
aspect returning the lower value from `Ordered.getValue()` (or the annotation value) has
the higher precedence.

When two pieces of advice defined in the same aspect both need to run at the same
join point, the ordering is undefined (since there is no way to retrieve the declaration
order through reflection for javac-compiled classes). Consider collapsing such advice
methods into one advice method per join point in each aspect class or refactor the
pieces of advice into separate aspect classes that you can order at the aspect level.



[[aop-introductions]]
=== Introductions

Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.

You can make an introduction by using the `@DeclareParents` annotation. This annotation is used
to declare that matching types have a new parent (hence the name). For example, given an
interface named `UsageTracked` and an implementation of that interface named `DefaultUsageTracked`,
the following aspect declares that all implementors of service interfaces also implement
the `UsageTracked` interface (to expose statistics via JMX for example):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class UsageTracking {

		@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
		public static UsageTracked mixin;

		@Before("com.xyz.myapp.SystemArchitecture.businessService() && this(usageTracked)")
		public void recordUsage(UsageTracked usageTracked) {
			usageTracked.incrementUseCount();
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class UsageTracking {

		companion object {
			@DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
			lateinit var mixin: UsageTracked
		}

		@Before("com.xyz.myapp.SystemArchitecture.businessService() && this(usageTracked)")
		fun recordUsage(usageTracked: UsageTracked) {
			usageTracked.incrementUseCount()
		}
	}
----

The interface to be implemented is determined by the type of the annotated field. The
`value` attribute of the `@DeclareParents` annotation is an AspectJ type pattern. Any
bean of a matching type implements the `UsageTracked` interface. Note that, in the
before advice of the preceding example, service beans can be directly used as
implementations of the `UsageTracked` interface. If accessing a bean programmatically,
you would write the following:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UsageTracked usageTracked = (UsageTracked) context.getBean("myService");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val usageTracked = context.getBean("myService") as UsageTracked
----


[[aop-instantiation-models]]
=== Aspect Instantiation Models

NOTE: This is an advanced topic. If you are just starting out with AOP, you can safely skip
it until later.

By default, there is a single instance of each aspect within the application
context. AspectJ calls this the singleton instantiation model. It is possible to define
aspects with alternate lifecycles. Spring supports AspectJ's `perthis` and `pertarget`
instantiation models ( `percflow, percflowbelow,` and `pertypewithin` are not currently
supported).

You can declare a `perthis` aspect by specifying a `perthis` clause in the `@Aspect`
annotation. Consider the following example:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
	public class MyAspect {

		private int someState;

		@Before(com.xyz.myapp.SystemArchitecture.businessService())
		public void recordServiceUsage() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
	class MyAspect {

		private val someState: Int = 0

		@Before(com.xyz.myapp.SystemArchitecture.businessService())
		fun recordServiceUsage() {
			// ...
		}

	}
----

In the preceding example, the effect of the `'perthis'` clause is that one aspect instance is created for
each unique service object that executes a business service (each unique object bound to
'this' at join points matched by the pointcut expression). The aspect instance is
created the first time that a method is invoked on the service object. The aspect goes
out of scope when the service object goes out of scope. Before the aspect instance is
created, none of the advice within it executes. As soon as the aspect instance has been
created, the advice declared within it executes at matched join points, but only
when the service object is the one with which this aspect is associated. See the AspectJ
Programming Guide for more information on `per` clauses.

The `pertarget` instantiation model works in exactly the same way as `perthis`, but it
creates one aspect instance for each unique target object at matched join points.



[[aop-ataspectj-example]]
=== An AOP Example

Now that you have seen how all the constituent parts work, we can put them together to do
something useful.

The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
`PessimisticLockingFailureException`. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.

Because we want to retry the operation, we need to use around advice so that we can
call `proceed` multiple times. The following listing shows the basic aspect implementation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class ConcurrentOperationExecutor implements Ordered {

		private static final int DEFAULT_MAX_RETRIES = 2;

		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;

		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;
		}

		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				}
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
				}
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class ConcurrentOperationExecutor : Ordered {

		private val DEFAULT_MAX_RETRIES = 2
		private var maxRetries = DEFAULT_MAX_RETRIES
		private var order = 1

		fun setMaxRetries(maxRetries: Int) {
			this.maxRetries = maxRetries
		}

		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}

		@Around("com.xyz.myapp.SystemArchitecture.businessService()")
		fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
			var numAttempts = 0
			var lockFailureException: PessimisticLockingFailureException
			do {
				numAttempts++
				try {
					return pjp.proceed()
				} catch (ex: PessimisticLockingFailureException) {
					lockFailureException = ex
				}

			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
		}
	}
----

Note that the aspect implements the `Ordered` interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The `maxRetries` and `order` properties are both configured by Spring. The
main action happens in the `doConcurrentOperation` around advice. Notice that, for the
moment, we apply the retry logic to each `businessService()`. We try to proceed,
and if we fail with a `PessimisticLockingFailureException`, we try again, unless
we have exhausted all of our retry attempts.

The corresponding Spring configuration follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>

	<bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor">
		<property name="maxRetries" value="3"/>
		<property name="order" value="100"/>
	</bean>
----

To refine the aspect so that it retries only idempotent operations, we might define the following
`Idempotent` annotation:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Idempotent {
		// marker annotation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	annotation class Idempotent// marker annotation
----

We can then use the annotation to annotate the implementation of service operations. The change
to the aspect to retry only idempotent operations involves refining the pointcut
expression so that only `@Idempotent` operations match, as follows:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("com.xyz.myapp.SystemArchitecture.businessService() && " +
			"@annotation(com.xyz.myapp.service.Idempotent)")
	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("com.xyz.myapp.SystemArchitecture.businessService() && " + "@annotation(com.xyz.myapp.service.Idempotent)")
	fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
		// ...
	}
----



